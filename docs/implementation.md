# Structure of the program
- The project consists of one program for playing the game and many programs that generate levels
  - gameUi.nim
    - The game ui/application. Opens levels that are generated by the programs mentioned below.
  - levels/*.nim
    - Programs that generate level files as a binary representation of Nim types (using [Frosty](https://github.com/disruptek/frosty))
- The programs use these libraries
  - graphs.nim
    - Implements a generic graph data structure using adjacency lists
  - geometry.nim
    - Implements vectors, vector operations and some geometry and math functions
  - levels.nim 
    - Implements the level format (data structure) and saving/loading the levels to/from the disk. Also includes functions for making levels that are used by level generating programs.
  - game.nim
    - Implements the game logic and the level solution checking algorithm
  - levelGfx.nim
    - Implements a coordinate transformation from the level coordinates (floats) to pixel coordinates for drawing (integers). Handles drawing the levels.

# Used data structures and algorithms
- Level format
	- An object (struct) that contains all the level data
	- Most important fields:
		- Graph for points in the levels, which lines can be drawn through (pointGraph)
		- Graph for cells that are between the lines (cellGraph) 
			- Saved as a separate graph, because the solution checking algorithm is simple to implement with separate graphs and mostly uses the cellGraph
		- Only the points and cells that change the rules of the game have their data saved in hash tables pointData and cellData (other points and cells are "empty")
	- The level format is designed with efficient implementation of the solution checking algorithm and rendering as the first priority
	- Serialized to binary for saving levels as files
- Graphs
	- Implemented using adjacency lists as hash tables
		- Keys correspond to nodes and have a generic type and values are generic hash sets, which contain the neighbors of a node
		- Generic types used, because the level format uses graphs to represent the level geometry and requires 2 different types as node values
			- A coordinate tuple is used for the points in the levels, which lines can be drawn through
			- A list (seq in Nim) of coordinates is used for the vertices of cells (rectangles between lines). This also makes it easy to extend the level format to allow other shapes than rectangles as the cells.
	- Use of hash tables and hash sets enables the use of generic types for node values
	- That also makes most graph changing operations and basic queries use constant time on average
	- Standard recursive DFS implementation used
- Game implementation
	- The main algorithm here is the level solution checking algorithm which consists of 6 steps
		1. Divide the level into rooms based on the drawn line, and find unsolved triangles and hexagons (all the following steps use the room division results)
		2. Find unsolved rectangles per room (based on rectangle counts for each color)
	  	3. Find unsolved stars in each room (based on number of stars and rectangles of each color)
	  	4. Find unsolved blocks in each room by using Algorithm X
	  	5. Cancel unsolved symbols if there are jacks in the room
	 	6. Level is solved if there are no symbols left unsolved and no jacks left unused (each jack has to cancel 1 unsolved symbol)
- Level rendering and UI
	- The levelGfx module implements a coordinate transform so that the levels can use arbitrary float coordinates and they should scale nicely to any screen resolution (uses mostly just basic vector math)

# Failed attempt at Algorithm X
At first I tried implementing dancing links algorithm x and at least my dancing links implementation was correct. The algorithm x itself was mostly working. However it didn't correctly identify some of the correct 
solutions. I couldn't make it work properly for some reason. That failed attempt can be found in experiments/dlx.nim (with a lot of debug prints but unfortunately no usage examples). I learned a lot about Algorithm X and
dancing links while trying to make the algorithm work. 

# Used Algorithm X implementation
Currently the project contains a working implementation of Algorithm X based on a very simple Python version I found online. This implementation uses hash tables
instead of dancing links to represent the problem matrix. I have changed many variable names from that original Python solution to be a lot more descriptive.

# Time complexity analysis
Most of the algorithms used depend on so many parameters that analyzing their time complexity doesn't make sense or doesn't give meaningful results. Also the puzzles in this game are mostly pretty small (largest puzzle I 
have in the levels is 8x8), because they need to be solvable by humans. There are a few algorithms that have meaningful time complexities:
- Normal depth first search in a graph has O(v + e) worst case time complexity where v is vertex count and e is edge count
- The room division algorithm has about the same time complexity as a DFS
	- There can be multiple DFS calls, but each cell is visited by a DFS exactly once
	- If a cell has already been visited (checked using a hash set), a DFS will not be started from that cell
- Algorithm X is a solution for the exact cover problem, which is a known NP complete problem. So the time complexity is exponential (of the form 2^n for example).

# Sources
Failed Algorithm X implementation was based on [this article](https://www.geeksforgeeks.org/exact-cover-problem-algorithm-x-set-2-implementation-dlx/) and the 2 wikipedia pages 
[Dancing links](https://www.wikiwand.com/en/Dancing_links) and [Algorithm X](https://www.wikiwand.com/en/Knuth%27s_Algorithm_X). The version of Algorithm X that is used in the game's solution checking is based on 
[this Python implementation](https://www.cs.mcgill.ca/~aassaf9/python/algorithm_x.html).

# What could be optimized/improved?
- The dual graph structure used is quite simple and makes the level editing functions simple
	- However the level solution algorithm would have been a bit simpler and slightly faster if it was a single graph with some data about the cells and points in it
	- Also that would have made it easier to keep e.g. the cells and points in sync
- The Algorithm X implementation is probably quite fast and it works
	- ...but it isn't tested with big enough inputs to know for sure that it would work with the biggest sensible The Witness levels
	- I didn't have the energy for that after the failed Algo X attempt already took quite a bit of time
	- Currently all block placements are iterated through using Algorithm X and only ones that don't use a single polyomino multiple times are accepted as solutions
	- In this context Algorithm X would be much faster if other placements of one polyomino were deleted as soon as it is placed somewhere
		- ...but that would require additional state tracking and backtracking logic
- This project wasn't supposed to be a 100% replica of all The Witness puzzles
	- ...but there are small planned things missing
	- I wanted to have all the currently implemented puzzle symbols interact correctly with each other, but right now every block is counted as unsolved when the solution is incorrect
		- Because of that blocks don't work correctly with jacks
		- It could be done by using the jacks to delete/cancel blocks before exact covers are attempted by Algo X
